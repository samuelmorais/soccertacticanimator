// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using QuickType;
//
//    var testJson = TestJson.FromJson(jsonString);

namespace QuickType
{
    using System;
    using System.Collections.Generic;

    using System.Globalization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;

    public partial class TestJson
    {
        [JsonProperty("playersAnimations")]
        public Dictionary<string, Animation[]> PlayersAnimations { get; set; }

        [JsonProperty("ballAnimations")]
        public Animation[] BallAnimations { get; set; }

        [JsonProperty("Name")]
        public string Name { get; set; }

        [JsonProperty("Animations")]
        public object Animations { get; set; }
    }

    public partial class Animation
    {
        [JsonProperty("debug")]
        public bool Debug { get; set; }

        [JsonProperty("NumFrames")]
        public long NumFrames { get; set; }

        [JsonProperty("KeyFrames")]
        public KeyFrame[] KeyFrames { get; set; }
    }

    public partial class KeyFrame
    {
        [JsonProperty("time")]
        public DateTimeOffset Time { get; set; }

        [JsonProperty("smooth")]
        public bool Smooth { get; set; }

        [JsonProperty("animIndex")]
        public long AnimIndex { get; set; }

        [JsonProperty("vec")]
        public Vec Vec { get; set; }

        [JsonProperty("Rotation", NullValueHandling = NullValueHandling.Ignore)]
        public RotationUnion? Rotation { get; set; }
    }

    public partial class Vec
    {
        [JsonProperty("x")]
        public double X { get; set; }

        [JsonProperty("y")]
        public double Y { get; set; }

        [JsonProperty("z")]
        public double Z { get; set; }
    }

    public enum RotationEnum { Infinity };

    public partial struct RotationUnion
    {
        public double? Double;
        public RotationEnum? Enum;

        public static implicit operator RotationUnion(double Double) => new RotationUnion { Double = Double };
        public static implicit operator RotationUnion(RotationEnum Enum) => new RotationUnion { Enum = Enum };
    }

    public partial class TestJson
    {
        public static TestJson FromJson(string json) => JsonConvert.DeserializeObject<TestJson>(json, QuickType.Converter.Settings);
    }

    /*public static class Serialize
    {
        public static string ToJson(this TestJson self) => JsonConvert.SerializeObject(self, QuickType.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                RotationUnionConverter.Singleton,
                RotationEnumConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }*/

    internal class RotationUnionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(RotationUnion) || t == typeof(RotationUnion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Integer:
                case JsonToken.Float:
                    var doubleValue = serializer.Deserialize<double>(reader);
                    return new RotationUnion { Double = doubleValue };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    if (stringValue == "Infinity")
                    {
                        return new RotationUnion { Enum = RotationEnum.Infinity };
                    }
                    break;
            }
            throw new Exception("Cannot unmarshal type RotationUnion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (RotationUnion)untypedValue;
            if (value.Double != null)
            {
                serializer.Serialize(writer, value.Double.Value);
                return;
            }
            if (value.Enum != null)
            {
                if (value.Enum == RotationEnum.Infinity)
                {
                    serializer.Serialize(writer, "Infinity");
                    return;
                }
            }
            throw new Exception("Cannot marshal type RotationUnion");
        }

        public static readonly RotationUnionConverter Singleton = new RotationUnionConverter();
    }

    internal class RotationEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(RotationEnum) || t == typeof(RotationEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "Infinity")
            {
                return RotationEnum.Infinity;
            }
            throw new Exception("Cannot unmarshal type RotationEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (RotationEnum)untypedValue;
            if (value == RotationEnum.Infinity)
            {
                serializer.Serialize(writer, "Infinity");
                return;
            }
            throw new Exception("Cannot marshal type RotationEnum");
        }

        public static readonly RotationEnumConverter Singleton = new RotationEnumConverter();
    }
}
